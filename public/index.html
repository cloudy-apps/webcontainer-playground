<link
  rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css"
/>
<link rel="stylesheet" href="/codemirror.css" />
<link rel="stylesheet" href="/xterm.css" />
<script src="/codemirror.js"></script>
<script src="/xterm.js"></script>
<script src="/xterm-addon-fit.js"></script>

<body class="bg-gray-900">
  <div id="app" class="h-screen flex flex-col">
    <div class="tabs flex border-b-2">
      <button class="tab py-2 px-4 text-white" data-target="terminal">
        Terminal
      </button>
      <button class="tab py-2 px-4 text-white" data-target="editor">
        Editor
      </button>
      <!-- <button class="tab py-2 px-4 text-white" data-target="preview">
        Preview
      </button> -->
    </div>
    <div class="tab-content w-full h-full">
      <div id="terminal" class="w-full h-full p-4 bg-black hidden"></div>

      <div id="editor" class="w-full h-full p-4 flex">
        <div id="code" class="flex-grow"></div>
      </div>

      <!-- <div id="preview" class="w-full h-full p-4 hidden">
        <iframe src="" id="preview-frame" class="w-full h-full"></iframe>
      </div> -->
    </div>
  </div>
</body>

<script type="module">
  import { WebContainer } from "https://unpkg.com/@webcontainer/api@1.1.5/dist/index.js";
  import { profilerc } from "./profilerc.js";

  const openfilePath = ".openfile";
  const consoleStream = new WritableStream({
    write(data) {
      console.log(data);
    },
  });

  async function exec(wc, command, args) {
    const cmd = await wc.spawn(command, args);
    return new Promise((write) =>
      cmd.output.pipeTo(new WritableStream({ write }))
    );
  }

  function debounce(fn) {
    let timer = 0;
    return (...args) => {
      clearTimeout(timer);
      timer = setTimeout(() => fn(...args), 300);
    };
  }

  async function getContainer() {
    const webcontainer = await WebContainer.boot();

    // webcontainer.on("server-ready", (port, url) => {
    //   document.getElementById("preview-frame").src = url;
    // });

    const tree = {
      [openfilePath]: {
        file: {
          contents: "",
        },
      },
      ".profile": {
        file: {
          contents: profilerc,
        },
      },
      workspace: {
        directory: {
          "index.js": {
            file: {
              contents: 'console.log("Hi!");',
            },
          },
        },
      },
    };

    await webcontainer.mount(tree);

    return webcontainer;
  }

  async function getEditor() {
    const codeMirror = CodeMirror(document.getElementById("code"), {
      lineNumbers: true,
    });
    window.addEventListener("resize", () => codeMirror.refresh());
    setTimeout(() => codeMirror.refresh(), 1);

    return codeMirror;
  }

  async function getTerminal() {
    const term = new Terminal({ convertEol: true });
    term.open(document.getElementById("terminal"));
    const fitAddon = new FitAddon.FitAddon();
    term.loadAddon(fitAddon);

    window.addEventListener("resize", () => fitAddon.fit());

    return term;
  }

  async function getShell({ webcontainer, terminal }) {
    const shell = await webcontainer.spawn("sh");

    window.addEventListener("resize", () => {
      shell.resize({
        cols: terminal.cols,
        rows: terminal.rows,
      });
    });

    let inputController;
    const input = new ReadableStream({
      start(controller) {
        inputController = controller;
        terminal.onData((data) => {
          controller.enqueue(data);
        });
      },
    });

    const output = new WritableStream({
      write(data) {
        terminal.write(data);
      },
    });

    shell.output.pipeTo(output);
    input.pipeTo(shell.input);

    const pwd = await exec(webcontainer, "pwd");
    inputController.enqueue(
      `export PATH="/bin:/usr/bin:/usr/local/bin:${pwd.trim()}"\n`
    );

    return { shell, inputController };
  }

  function getTabs({ editor, terminal, preview }) {
    const tabs = document.querySelectorAll(".tab");
    const handlers = {
      editor: () => editor.refresh(),
      terminal: () => terminal.focus(),
      // preview: () => preview.focus(),
    };

    const openTab = (target) => {
      const tabContents = document.querySelectorAll(".tab-content > div");

      tabs.forEach((tab) => tab.classList.remove("bg-blue-400"));
      tabContents.forEach((t) => {
        if (t.id === target) {
          t.classList.remove("hidden");
          tab.classList.add("bg-blue-400");
          setTimeout(handlers[target], 1);
          return;
        }

        t.classList.add("hidden");
      });
    };

    tabs.forEach((tab) => {
      tab.addEventListener("click", () => openTab(tab.dataset.target));
    });

    document.addEventListener(
      "keypress",
      (event) => {
        if (!(event.altKey && event.shiftKey)) {
          return;
        }

        const id = Number(event.code.replace("Digit", ""));
        if (id && tabs[id - 1]) {
          tabs[id - 1].click();
        }
      },
      { capture: true }
    );

    return { openTab };
  }

  window.addEventListener("DOMContentLoaded", async () => {
    const currentFile = { path: "" };
    const editor = await getEditor();
    const terminal = await getTerminal();
    const webcontainer = await getContainer();
    const preview = document.getElementById("preview-frame");
    const tabs = await getTabs({ editor, terminal, preview });
    const { shell, inputController } = await getShell({
      terminal,
      webcontainer,
    });

    editor.on(
      "change",
      debounce(() => {
        if (currentFile.path) {
          webcontainer.fs.writeFile(currentFile.path, editor.getValue());
        }
      })
    );

    await webcontainer.fs.writeFile(openfilePath, "");

    async function openFile() {
      const file = await webcontainer.fs.readFile(openfilePath, "utf8");

      if (file) {
        editor.setValue(webcontainer.fs.readFile(file, "utf-8"));
        webcontainer.fs.writeFile(openfilePath, "");
        tabs.openTab("editor");
      }
    }

    setInterval(openFile, 1000);

    window.ui = { terminal, editor, webcontainer, shell, inputController };
  });
</script>
